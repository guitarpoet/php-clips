   /*******************************************************/
   /*      "C" Language Integrated Production System      */
   /*                                                     */
   /*            CLIPS Version 6.40  01/06/16             */
   /*                                                     */
   /*            MISCELLANEOUS FUNCTIONS MODULE           */
   /*******************************************************/

/*************************************************************/
/* Purpose:                                                  */
/*                                                           */
/* Principal Programmer(s):                                  */
/*      Gary D. Riley                                        */
/*                                                           */
/* Contributing Programmer(s):                               */
/*      Brian L. Dantes                                      */
/*                                                           */
/* Revision History:                                         */
/*                                                           */
/*      6.23: Correction for FalseSymbol/TrueSymbol. DR0859  */
/*                                                           */
/*            Corrected compilation errors for files         */
/*            generated by constructs-to-c. DR0861           */
/*                                                           */
/*            Changed name of variable exp to theExp         */
/*            because of Unix compiler warnings of shadowed  */
/*            definitions.                                   */
/*                                                           */
/*      6.24: Removed CONFLICT_RESOLUTION_STRATEGIES,        */
/*            DYNAMIC_SALIENCE, INCREMENTAL_RESET,           */
/*            LOGICAL_DEPENDENCIES, IMPERATIVE_METHODS       */
/*            INSTANCE_PATTERN_MATCHING,                     */
/*            IMPERATIVE_MESSAGE_HANDLERS, and               */
/*            AUXILIARY_MESSAGE_HANDLERS compilation flags.  */
/*                                                           */
/*            Renamed BOOLEAN macro type to intBool.         */
/*                                                           */
/*      6.30: Support for long long integers.                */
/*                                                           */
/*            Used gensprintf instead of sprintf.            */
/*                                                           */
/*            Removed conditional code for unsupported       */
/*            compilers/operating systems.                   */
/*                                                           */
/*            Renamed EX_MATH compiler flag to               */
/*            EXTENDED_MATH_FUNCTIONS.                       */
/*                                                           */
/*            Combined BASIC_IO and EXT_IO compilation       */
/*            flags into the IO_FUNCTIONS compilation flag.  */
/*                                                           */    
/*            Removed code associated with HELP_FUNCTIONS    */
/*            and EMACS_EDITOR compiler flags.               */
/*                                                           */    
/*            Added operating-system function.               */
/*                                                           */ 
/*            Added new function (for future use).           */
/*                                                           */ 
/*            Added const qualifiers to remove C++           */
/*            deprecation warnings.                          */
/*                                                           */
/*            Removed deallocating message parameter from    */
/*            EnvReleaseMem.                                 */
/*                                                           */
/*            Removed support for BLOCK_MEMORY.              */
/*                                                           */
/*      6.40: Refactored code to reduce header dependencies  */
/*            in sysdep.c.                                   */
/*                                                           */
/*            Added Env prefix to GetEvaluationError and     */
/*            SetEvaluationError functions.                  */
/*                                                           */
/*            Added Env prefix to GetHaltExecution and       */
/*            SetHaltExecution functions.                    */
/*                                                           */
/*            Changed restrictions from char * to            */
/*            symbolHashNode * to support strings            */
/*            originating from sources that are not          */
/*            statically allocated.                          */
/*                                                           */
/*            Fact ?var:slot reference support.              */
/*                                                           */
/*            Added local-time and gm-time functions.        */
/*                                                           */
/*************************************************************/

#include <stdio.h>
#include <string.h>
#include <time.h>

#include "setup.h"

#include "argacces.h"
#include "envrnmnt.h"
#include "exprnpsr.h"
#include "memalloc.h"
#include "multifld.h"
#include "router.h"
#include "sysdep.h"
#include "utility.h"

#if DEFFUNCTION_CONSTRUCT
#include "dffnxfun.h"
#endif

#if DEFTEMPLATE_CONSTRUCT
#include "factfun.h"
#include "tmpltutl.h"
#endif

#include "miscfun.h"

#define MISCFUN_DATA 9

struct miscFunctionData
  { 
   long long GensymNumber;
  };

#define MiscFunctionData(theEnv) ((struct miscFunctionData *) GetEnvironmentData(theEnv,MISCFUN_DATA))

/***************************************/
/* LOCAL INTERNAL FUNCTION DEFINITIONS */
/***************************************/

   static void                    ExpandFuncMultifield(void *,DATA_OBJECT *,EXPRESSION *,
                                                       EXPRESSION **,void *);
   static int                     FindLanguageType(void *,const char *);
   static void                    ConvertTime(void *,CLIPSValue *,struct tm *);

/*****************************************************************/
/* MiscFunctionDefinitions: Initializes miscellaneous functions. */
/*****************************************************************/
void MiscFunctionDefinitions(
  void *theEnv)
  {
   AllocateEnvironmentData(theEnv,MISCFUN_DATA,sizeof(struct miscFunctionData),NULL);
   MiscFunctionData(theEnv)->GensymNumber = 1;
   
#if ! RUN_TIME
   EnvAddUDF(theEnv,"gensym",       "y", GensymFunction,     "GensymFunction",    0,0,NULL,NULL);
   EnvAddUDF(theEnv,"gensym*",      "y", GensymStarFunction, "GensymStarFunction",0,0,NULL,NULL);
   EnvAddUDF(theEnv,"setgen",       "l", SetgenFunction,     "SetgenFunction",    1,1,"l", NULL);
   
   EnvAddUDF(theEnv,"system",       "v", SystemCommand,      "SystemCommand", 1, UNBOUNDED , "sy" , NULL );
   EnvAddUDF(theEnv,"length",       "l", LengthFunction,     "LengthFunction", 1,1, "sym" ,NULL);
   EnvAddUDF(theEnv,"length$",      "l", LengthFunction,     "LengthFunction", 1,1, "sym", NULL);
   EnvAddUDF(theEnv,"time",         "d", TimeFunction,       "TimeFunction", 0,0,NULL,NULL);
   EnvAddUDF(theEnv,"local-time",   "m", LocalTimeFunction,  "LocalTimeFunction", 0,0,NULL,NULL);
   EnvAddUDF(theEnv,"gm-time",      "m", GMTimeFunction,     "GMTimeFunction", 0,0,NULL,NULL);

   EnvAddUDF(theEnv,"random",       "l", RandomFunction,     "RandomFunction", 0,2, "l" ,NULL);
   EnvAddUDF(theEnv,"seed",         "v", SeedFunction,       "SeedFunction", 1,1,"l", NULL);
   EnvAddUDF(theEnv,"conserve-mem", "v", ConserveMemCommand, "ConserveMemCommand", 1,1,"y",NULL);
   EnvAddUDF(theEnv,"release-mem",  "l", ReleaseMemCommand,  "ReleaseMemCommand", 0,0,NULL,NULL);
#if DEBUGGING_FUNCTIONS
   EnvAddUDF(theEnv,"mem-used",     "l", MemUsedCommand,     "MemUsedCommand", 0,0,NULL,NULL);
   EnvAddUDF(theEnv,"mem-requests", "l", MemRequestsCommand, "MemRequestsCommand", 0,0,NULL,NULL);
#endif

   EnvAddUDF(theEnv,"options",      "v", OptionsCommand,    "OptionsCommand",    0,0,NULL, NULL);

   EnvAddUDF(theEnv,"operating-system", "y", OperatingSystemFunction,"OperatingSystemFunction", 0,0,NULL,NULL);
   EnvAddUDF(theEnv,"(expansion-call)", "*", ExpandFuncCall,      "ExpandFuncCall", 0,UNBOUNDED,NULL,NULL);
   EnvAddUDF(theEnv,"expand$","*",  DummyExpandFuncMultifield,
                                           "DummyExpandFuncMultifield",1,1,"m",NULL);
   FuncSeqOvlFlags(theEnv,"expand$",false,false);
   EnvAddUDF(theEnv,"(set-evaluation-error)",
                                       "y", CauseEvaluationError,"CauseEvaluationError",0,0,NULL,NULL);
   EnvAddUDF(theEnv,"set-sequence-operator-recognition",
                                       "b",  SetSORCommand,"SetSORCommand",1,1,"y",NULL);
   EnvAddUDF(theEnv,"get-sequence-operator-recognition","b",
                     GetSORCommand,"GetSORCommand",0,0,NULL,NULL);
   EnvAddUDF(theEnv,"get-function-restrictions","s",
                    GetFunctionRestrictions,"GetFunctionRestrictions",1,1,"y",NULL);
   EnvAddUDF(theEnv,"create$",           "m",  CreateFunction,  "CreateFunction", 0,UNBOUNDED,NULL,NULL);
   EnvAddUDF(theEnv,"apropos",           "v", AproposCommand,  "AproposCommand", 1,1,"y",NULL);
   EnvAddUDF(theEnv,"get-function-list", "m", GetFunctionListFunction,  "GetFunctionListFunction",0,0,NULL,NULL);
   EnvAddUDF(theEnv,"funcall",           "*",  FuncallFunction,"FuncallFunction",1,UNBOUNDED,"*;sy",NULL);
   EnvAddUDF(theEnv,"new",               "*",  NewFunction,"NewFunction",1,UNBOUNDED,"*;y",NULL);
   EnvAddUDF(theEnv,"call",              "*",  CallFunction,"CallFunction",1,UNBOUNDED,"*",NULL);
   EnvAddUDF(theEnv,"timer",             "d",  TimerFunction,"TimerFunction",0,UNBOUNDED,NULL,NULL);
#if DEFTEMPLATE_CONSTRUCT 
   EnvAddUDF(theEnv,"(slot-value)",      "*", SlotValueFunction,"SlotValueFunction", 3,3,"y;z",NULL);
#endif
#endif
  }

/******************************************************************/
/* CreateFunction: H/L access routine for the create$ function.   */
/******************************************************************/
void CreateFunction(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   Environment *theEnv = UDFContextEnvironment(context);
   
   StoreInMultifield(theEnv,returnValue,GetFirstArgument(),true);
  }

/*****************************************************************/
/* SetgenFunction: H/L access routine for the setgen function.   */
/*****************************************************************/
void SetgenFunction(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   CLIPSInteger theLong;
   void *theEnv = UDFContextEnvironment(context);

   /*====================================================*/
   /* Check to see that an integer argument is provided. */
   /*====================================================*/

   if (! UDFNthArgument(context,1,INTEGER_TYPE,returnValue))
     { return; }

   /*========================================*/
   /* The integer must be greater than zero. */
   /*========================================*/

   theLong = mCVToInteger(returnValue);

   if (theLong < 1LL)
     {
      UDFInvalidArgumentMessage(context,"integer (greater than or equal to 1)");
      mCVSetInteger(returnValue,MiscFunctionData(theEnv)->GensymNumber);
      return;
     }

   /*==============================================*/
   /* Set the gensym index to the number provided. */
   /*==============================================*/

   MiscFunctionData(theEnv)->GensymNumber = theLong;
  }

/****************************************/
/* GensymFunction: H/L access routine   */
/*   for the gensym function.           */
/****************************************/
void GensymFunction(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   void *theEnv = UDFContextEnvironment(context);
   char genstring[128];
   
   /*================================================*/
   /* Create a symbol using the current gensym index */
   /* as the postfix.                                */
   /*================================================*/

   gensprintf(genstring,"gen%lld",MiscFunctionData(theEnv)->GensymNumber);
   MiscFunctionData(theEnv)->GensymNumber++;

   /*====================*/
   /* Return the symbol. */
   /*====================*/

   mCVSetSymbol(returnValue,genstring);
  }

/************************************************/
/* GensymStarFunction: H/L access routine for   */
/*   the gensym* function.                      */
/************************************************/
void GensymStarFunction(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   /*====================*/
   /* Return the symbol. */
   /*====================*/

   GensymStar(UDFContextEnvironment(context),returnValue);
  }

/************************************/
/* GensymStar: C access routine for */
/*   the gensym* function.          */
/************************************/
void GensymStar(
  void *theEnv,
  CLIPSValue *returnValue)
  {
   char genstring[128];
   
   /*=======================================================*/
   /* Create a symbol using the current gensym index as the */
   /* postfix. If the symbol is already present in the      */
   /* symbol table, then continue generating symbols until  */
   /* a unique symbol is found.                             */
   /*=======================================================*/

   do
     {
      gensprintf(genstring,"gen%lld",MiscFunctionData(theEnv)->GensymNumber);
      MiscFunctionData(theEnv)->GensymNumber++;
     }
   while (FindSymbolHN(theEnv,genstring) != NULL);

   /*====================*/
   /* Return the symbol. */
   /*====================*/

   mEnvCVInit(theEnv,returnValue);
   mCVSetSymbol(returnValue,genstring);
  }

/********************************************/
/* RandomFunction: H/L access routine for   */
/*   the random function.                   */
/********************************************/
void RandomFunction(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   int argCount;
   CLIPSInteger rv;
   CLIPSValue theArg;
   CLIPSInteger begin, end;
   Environment *theEnv = UDFContextEnvironment(context);

   /*====================================*/
   /* The random function accepts either */
   /* zero or two arguments.             */
   /*====================================*/

   argCount = UDFArgumentCount(context);
   
   if ((argCount != 0) && (argCount != 2))
     {
      PrintErrorID(theEnv,"MISCFUN",2,false);
      EnvPrintRouter(theEnv,WERROR,"Function random expected either 0 or 2 arguments\n"); 
     }

   /*========================================*/
   /* Return the randomly generated integer. */
   /*========================================*/

   rv = genrand();
   
   if (argCount == 2)
     {
      if (! UDFFirstArgument(context,INTEGER_TYPE,&theArg))
        { return; }
      begin = mCVToInteger(&theArg);
      
      if (! UDFNextArgument(context,INTEGER_TYPE,&theArg))
        { return; }
      end = mCVToInteger(&theArg);
      
      if (end < begin)
        {
         PrintErrorID(theEnv,"MISCFUN",3,false);
         EnvPrintRouter(theEnv,WERROR,"Function random expected argument #1 to be less than argument #2\n"); 
         mCVSetInteger(returnValue,rv);
         return;
        }
        
      rv = begin + (rv % ((end - begin) + 1));
     }
   
   
   mCVSetInteger(returnValue,rv);
  }

/******************************************/
/* SeedFunction: H/L access routine for   */
/*   the seed function.                   */
/******************************************/
void SeedFunction(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   CLIPSValue theValue;

   /*==========================================================*/
   /* Check to see that a single integer argument is provided. */
   /*==========================================================*/

   if (! UDFFirstArgument(context,INTEGER_TYPE,&theValue))
     { return; }
     
   /*=============================================================*/
   /* Seed the random number generator with the provided integer. */
   /*=============================================================*/

   genseed((int) mCVToInteger(&theValue));
  }

/********************************************/
/* LengthFunction: H/L access routine for   */
/*   the length$ function.                  */
/********************************************/
void LengthFunction(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   CLIPSValue theArg;

   /*====================================================*/
   /* The length$ function expects exactly one argument. */
   /*====================================================*/

   if (! UDFFirstArgument(context, LEXEME_TYPES | MULTIFIELD_TYPE, &theArg))
     { return; }

   /*====================================================*/
   /* If the argument is a string or symbol, then return */
   /* the number of characters in the argument.          */
   /*====================================================*/

   if (mCVIsType(&theArg,LEXEME_TYPES))
     {
      mCVSetInteger(returnValue,strlen(mCVToString(&theArg)));
      return;
     }

   /*====================================================*/
   /* If the argument is a multifield value, then return */
   /* the number of fields in the argument.              */
   /*====================================================*/

   if (mCVIsType(&theArg,MULTIFIELD_TYPE))
     {
      mCVSetInteger(returnValue,MFLength(&theArg));
      return;
     }
  }

/*******************************************/
/* ReleaseMemCommand: H/L access routine   */
/*   for the release-mem function.         */
/*******************************************/
void ReleaseMemCommand(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   /*========================================*/
   /* Release memory to the operating system */
   /* and return the amount of memory freed. */
   /*========================================*/

   mCVSetInteger(returnValue,EnvReleaseMem(UDFContextEnvironment(context),-1L));
  }

/******************************************/
/* ConserveMemCommand: H/L access routine */
/*   for the conserve-mem command.        */
/******************************************/
void ConserveMemCommand(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   const char *argument;
   CLIPSValue theValue;
   Environment *theEnv = UDFContextEnvironment(context);

   /*===================================*/
   /* The conserve-mem function expects */
   /* a single symbol argument.         */
   /*===================================*/

   if (! UDFFirstArgument(context,SYMBOL_TYPE,&theValue))
     { return; }
     
   argument = mCVToString(&theValue);

   /*====================================================*/
   /* If the argument is the symbol "on", then store the */
   /* pretty print representation of a construct when it */
   /* is defined.                                        */
   /*====================================================*/

   if (strcmp(argument,"on") == 0)
     { EnvSetConserveMemory(theEnv,true); }

   /*======================================================*/
   /* Otherwise, if the argument is the symbol "off", then */
   /* don't store the pretty print representation of a     */
   /* construct when it is defined.                        */
   /*======================================================*/

   else if (strcmp(argument,"off") == 0)
     { EnvSetConserveMemory(theEnv,false); }

   /*=====================================================*/
   /* Otherwise, generate an error since the only allowed */
   /* arguments are "on" or "off."                        */
   /*=====================================================*/

   else
     {
      UDFInvalidArgumentMessage(context,"symbol with value on or off");
      return;
     }

   return;
  }

#if DEBUGGING_FUNCTIONS

/****************************************/
/* MemUsedCommand: H/L access routine   */
/*   for the mem-used command.          */
/****************************************/
void MemUsedCommand(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   /*============================================*/
   /* Return the amount of memory currently held */
   /* (both for current use and for later use).  */
   /*============================================*/

   mCVSetInteger(returnValue,EnvMemUsed(UDFContextEnvironment(context)));
  }

/********************************************/
/* MemRequestsCommand: H/L access routine   */
/*   for the mem-requests command.          */
/********************************************/
void MemRequestsCommand(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   /*==================================*/
   /* Return the number of outstanding */
   /* memory requests.                 */
   /*==================================*/

   mCVSetInteger(returnValue,EnvMemRequests(UDFContextEnvironment(context)));
  }

#endif

/****************************************/
/* AproposCommand: H/L access routine   */
/*   for the apropos command.           */
/****************************************/
void AproposCommand(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   const char *argument;
   DATA_OBJECT argPtr;
   struct symbolHashNode *hashPtr = NULL;
   size_t theLength;
   Environment *theEnv = UDFContextEnvironment(context);

   /*=======================================================*/
   /* The apropos command expects a single symbol argument. */
   /*=======================================================*/

   if (! UDFFirstArgument(context,SYMBOL_TYPE,&argPtr))
     { return; }

   /*=======================================*/
   /* Determine the length of the argument. */
   /*=======================================*/

   argument = mCVToString(&argPtr);
   theLength = strlen(argument);

   /*====================================================================*/
   /* Print each entry in the symbol table that contains the argument as */
   /* a substring. When using a non-ANSI compiler, only those strings    */
   /* that contain the substring starting at the beginning of the string */
   /* are printed.                                                       */
   /*====================================================================*/

   while ((hashPtr = GetNextSymbolMatch(theEnv,argument,theLength,hashPtr,true,NULL)) != NULL)
     {
      EnvPrintRouter(theEnv,WDISPLAY,ValueToString(hashPtr));
      EnvPrintRouter(theEnv,WDISPLAY,"\n");
     }
  }

/****************************************/
/* OptionsCommand: H/L access routine   */
/*   for the options command.           */
/****************************************/
void OptionsCommand(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   void *theEnv = UDFContextEnvironment(context);

   /*=======================*/
   /* Set the return value. */
   /*=======================*/
   
   mCVSetVoid(returnValue);
   
   /*=================================*/
   /* Print the state of the compiler */
   /* flags for this executable.      */
   /*=================================*/

   EnvPrintRouter(theEnv,WDISPLAY,"Machine type: ");

#if GENERIC
   EnvPrintRouter(theEnv,WDISPLAY,"Generic ");
#endif
#if UNIX_V
   EnvPrintRouter(theEnv,WDISPLAY,"UNIX System V or 4.2BSD ");
#endif
#if DARWIN
   EnvPrintRouter(theEnv,WDISPLAY,"Darwin ");
#endif
#if LINUX
   EnvPrintRouter(theEnv,WDISPLAY,"Linux ");
#endif
#if UNIX_7
   EnvPrintRouter(theEnv,WDISPLAY,"UNIX System III Version 7 or Sun Unix ");
#endif
#if MAC_XCD
   EnvPrintRouter(theEnv,WDISPLAY,"Apple Macintosh with Xcode");
#endif
#if WIN_MVC
   EnvPrintRouter(theEnv,WDISPLAY,"Microsoft Windows with Microsoft Visual C++");
#endif
#if WIN_GCC
   EnvPrintRouter(theEnv,WDISPLAY,"Microsoft Windows with DJGPP");
#endif
EnvPrintRouter(theEnv,WDISPLAY,"\n");

EnvPrintRouter(theEnv,WDISPLAY,"Defrule construct is ");
#if DEFRULE_CONSTRUCT
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Defmodule construct is ");
#if DEFMODULE_CONSTRUCT
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Deftemplate construct is ");
#if DEFTEMPLATE_CONSTRUCT
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"  Fact-set queries are ");
#if FACT_SET_QUERIES
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

#if DEFTEMPLATE_CONSTRUCT

EnvPrintRouter(theEnv,WDISPLAY,"  Deffacts construct is ");
#if DEFFACTS_CONSTRUCT
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

#endif

EnvPrintRouter(theEnv,WDISPLAY,"Defglobal construct is ");
#if DEFGLOBAL_CONSTRUCT
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Deffunction construct is ");
#if DEFFUNCTION_CONSTRUCT
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Defgeneric/Defmethod constructs are ");
#if DEFGENERIC_CONSTRUCT
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Object System is ");
#if OBJECT_SYSTEM
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

#if OBJECT_SYSTEM

EnvPrintRouter(theEnv,WDISPLAY,"  Definstances construct is ");
#if DEFINSTANCES_CONSTRUCT
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"  Instance-set queries are ");
#if INSTANCE_SET_QUERIES
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"  Binary loading of instances is ");
#if BLOAD_INSTANCES
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"  Binary saving of instances is ");
#if BSAVE_INSTANCES
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

#endif

EnvPrintRouter(theEnv,WDISPLAY,"Extended math function package is ");
#if EXTENDED_MATH_FUNCTIONS
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Text processing function package is ");
#if TEXTPRO_FUNCTIONS
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Bload capability is ");
#if BLOAD_ONLY
  EnvPrintRouter(theEnv,WDISPLAY,"BLOAD ONLY");
#endif
#if BLOAD
  EnvPrintRouter(theEnv,WDISPLAY,"BLOAD");
#endif
#if BLOAD_AND_BSAVE
  EnvPrintRouter(theEnv,WDISPLAY,"BLOAD AND BSAVE");
#endif
#if (! BLOAD_ONLY) && (! BLOAD) && (! BLOAD_AND_BSAVE)
  EnvPrintRouter(theEnv,WDISPLAY,"OFF ");
#endif
EnvPrintRouter(theEnv,WDISPLAY,"\n");

EnvPrintRouter(theEnv,WDISPLAY,"Construct compiler is ");
#if CONSTRUCT_COMPILER
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"I/O function package is ");
#if IO_FUNCTIONS
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"String function package is ");
#if STRING_FUNCTIONS
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Multifield function package is ");
#if MULTIFIELD_FUNCTIONS
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Debugging function package is ");
#if DEBUGGING_FUNCTIONS
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Window Interface flag is ");
#if WINDOW_INTERFACE
   EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
   EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Developer flag is ");
#if DEVELOPER
   EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
   EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Run time module is ");
#if RUN_TIME
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif
  }

/***********************************************/
/* OperatingSystemFunction: H/L access routine */
/*   for the operating system function.        */
/***********************************************/
void OperatingSystemFunction(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
#if GENERIC
   mCVSetSymbol(returnValue,"UNKNOWN");
#elif UNIX_V
   mCVSetSymbol(returnValue,"UNIX-V");
#elif UNIX_7
   mCVSetSymbol(returnValue,"UNIX-7");
#elif LINUX
   mCVSetSymbol(returnValue,"LINUX");
#elif DARWIN
   mCVSetSymbol(returnValue,"DARWIN");
#elif MAC_XCD
   mCVSetSymbol(returnValue,"MAC-OS-X");
#elif IBM && (! WINDOW_INTERFACE)
   mCVSetSymbol(returnValue,"DOS");
#elif IBM && WINDOW_INTERFACE
   mCVSetSymbol(returnValue,"WINDOWS");
#else
   mCVSetSymbol(returnValue,"UNKNOWN");
#endif
  }
  
/********************************************************************
  NAME         : ExpandFuncCall
  DESCRIPTION  : This function is a wrap-around for a normal
                   function call.  It preexamines the argument
                   expression list and expands any references to the
                   sequence operator.  It builds a copy of the
                   function call expression with these new arguments
                   inserted and evaluates the function call.
  INPUTS       : A data object buffer
  RETURNS      : Nothing useful
  SIDE EFFECTS : Expressions alloctaed/deallocated
                 Function called and arguments evaluated
                 EvaluationError set on errors
  NOTES        : None
 *******************************************************************/
void ExpandFuncCall(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   EXPRESSION *newargexp,*fcallexp;
   struct FunctionDefinition *func;
   Environment *theEnv = UDFContextEnvironment(context);

   /* ======================================================================
      Copy the original function call's argument expression list.
      Look for expand$ function callsexpressions and replace those
        with the equivalent expressions of the expansions of evaluations
        of the arguments.
      ====================================================================== */
   newargexp = CopyExpression(theEnv,GetFirstArgument()->argList);
   ExpandFuncMultifield(theEnv,returnValue,newargexp,&newargexp,
                        (void *) FindFunction(theEnv,"expand$"));

   /* ===================================================================
      Build the new function call expression with the expanded arguments.
      Check the number of arguments, if necessary, and call the thing.
      =================================================================== */
   fcallexp = get_struct(theEnv,expr);
   fcallexp->type = GetFirstArgument()->type;
   fcallexp->value = GetFirstArgument()->value;
   fcallexp->nextArg = NULL;
   fcallexp->argList = newargexp;
   if (fcallexp->type == FCALL)
     {
      func = (struct FunctionDefinition *) fcallexp->value;
      if (CheckFunctionArgCount(theEnv,func,CountArguments(newargexp)) == false)
        {
         mCVSetBoolean(returnValue,false);
         ReturnExpression(theEnv,fcallexp);
         return;
        }
     }
#if DEFFUNCTION_CONSTRUCT
   else if (fcallexp->type == PCALL)
     {
      if (CheckDeffunctionCall(theEnv,fcallexp->value,
              CountArguments(fcallexp->argList)) == false)
        {
         mCVSetBoolean(returnValue,false);
         ReturnExpression(theEnv,fcallexp);
         EnvSetEvaluationError(theEnv,true);
         return;
        }
     }
#endif

   EvaluateExpression(theEnv,fcallexp,returnValue);
   ReturnExpression(theEnv,fcallexp);
  }

/***********************************************************************
  NAME         : DummyExpandFuncMultifield
  DESCRIPTION  : The expansion of multifield arguments is valid only
                 when done for a function call.  All these expansions
                 are handled by the H/L wrap-around function
                 (expansion-call) - see ExpandFuncCall.  If the H/L
                 function, epand-multifield is ever called directly,
                 it is an error.
  INPUTS       : Data object buffer
  RETURNS      : Nothing useful
  SIDE EFFECTS : EvaluationError set
  NOTES        : None
 **********************************************************************/
void DummyExpandFuncMultifield(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   Environment *theEnv = UDFContextEnvironment(context);
   
   mCVSetBoolean(returnValue,false);
   EnvSetEvaluationError(theEnv,true);
   PrintErrorID(theEnv,"MISCFUN",1,false);
   EnvPrintRouter(theEnv,WERROR,"expand$ must be used in the argument list of a function call.\n");
  }

/***********************************************************************
  NAME         : ExpandFuncMultifield
  DESCRIPTION  : Recursively examines an expression and replaces
                   PROC_EXPAND_MULTIFIELD expressions with the expanded
                   evaluation expression of its argument
  INPUTS       : 1) A data object result buffer
                 2) The expression to modify
                 3) The address of the expression, in case it is
                    deleted entirely
                 4) The address of the H/L function expand$
  RETURNS      : Nothing useful
  SIDE EFFECTS : Expressions allocated/deallocated as necessary
                 Evaluations performed
                 On errors, argument expression set to call a function
                   which causes an evaluation error when evaluated
                   a second time by actual caller.
  NOTES        : THIS ROUTINE MODIFIES EXPRESSIONS AT RUNTIME!!  MAKE
                 SURE THAT THE EXPRESSION PASSED IS SAFE TO CHANGE!!
 **********************************************************************/
static void ExpandFuncMultifield(
  void *theEnv,
  DATA_OBJECT *result,
  EXPRESSION *theExp,
  EXPRESSION **sto,
  void *expmult)
  {
   EXPRESSION *newexp,*top,*bot;
   register long i; /* 6.04 Bug Fix */

   while (theExp != NULL)
     {
      if (theExp->value == expmult)
        {
         EvaluateExpression(theEnv,theExp->argList,result);
         ReturnExpression(theEnv,theExp->argList);
         if ((EvaluationData(theEnv)->EvaluationError) || (result->type != MULTIFIELD))
           {
            theExp->argList = NULL;
            if ((EvaluationData(theEnv)->EvaluationError == false) && (result->type != MULTIFIELD))
              ExpectedTypeError2(theEnv,"expand$",1);
            theExp->value = (void *) FindFunction(theEnv,"(set-evaluation-error)");
            EvaluationData(theEnv)->EvaluationError = false;
            EvaluationData(theEnv)->HaltExecution = false;
            return;
           }
         top = bot = NULL;
         for (i = GetpDOBegin(result) ; i <= GetpDOEnd(result) ; i++)
           {
            newexp = get_struct(theEnv,expr);
            newexp->type = GetMFType(result->value,i);
            newexp->value = GetMFValue(result->value,i);
            newexp->argList = NULL;
            newexp->nextArg = NULL;
            if (top == NULL)
              top = newexp;
            else
              bot->nextArg = newexp;
            bot = newexp;
           }
         if (top == NULL)
           {
            *sto = theExp->nextArg;
            rtn_struct(theEnv,expr,theExp);
            theExp = *sto;
           }
         else
           {
            bot->nextArg = theExp->nextArg;
            *sto = top;
            rtn_struct(theEnv,expr,theExp);
            sto = &bot->nextArg;
            theExp = bot->nextArg;
           }
        }
      else
        {
         if (theExp->argList != NULL)
           ExpandFuncMultifield(theEnv,result,theExp->argList,&theExp->argList,expmult);
         sto = &theExp->nextArg;
         theExp = theExp->nextArg;
        }
     }
  }

/****************************************************************
  NAME         : CauseEvaluationError
  DESCRIPTION  : Dummy function use to cause evaluation errors on
                   a function call to generate error messages
  INPUTS       : None
  RETURNS      : A pointer to the FalseSymbol
  SIDE EFFECTS : EvaluationError set
  NOTES        : None
 ****************************************************************/
void CauseEvaluationError(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   EnvSetEvaluationError(UDFContextEnvironment(context),true);
   mCVSetBoolean(returnValue,false);
  }

/*****************/
/* GetSORCommand */
/*****************/
void GetSORCommand(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   Environment *theEnv = UDFContextEnvironment(context);
   
   mCVSetBoolean(returnValue,EnvGetSequenceOperatorRecognition(theEnv));
  }

/****************************************************************
  NAME         : SetSORCommand
  DESCRIPTION  : Toggles SequenceOpMode - if true, multifield
                   references are replaced with sequence
                   expansion operators
  INPUTS       : None
  RETURNS      : The old value of SequenceOpMode
  SIDE EFFECTS : SequenceOpMode toggled
  NOTES        : None
 ****************************************************************/
void SetSORCommand(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   Environment *theEnv = UDFContextEnvironment(context);
#if (! RUN_TIME) && (! BLOAD_ONLY)
   DATA_OBJECT theArg;
   
   if (! UDFFirstArgument(context,SYMBOL_TYPE,&theArg))
     { return; }
     
   mCVSetBoolean(returnValue,EnvSetSequenceOperatorRecognition(theEnv,(CVIsFalseSymbol(&theArg) ?
                                                                      false : true)));
#else
    mCVSetBoolean(returnValue,ExpressionData(theEnv)->SequenceOpMode);
#endif
  }

/********************************************************************
  NAME         : GetFunctionRestrictions
  DESCRIPTION  : Gets DefineFunction2() restriction list for function
  INPUTS       : None
  RETURNS      : A string containing the function restriction codes
  SIDE EFFECTS : EvaluationError set on errors
  NOTES        : None
 ********************************************************************/
void GetFunctionRestrictions(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   CLIPSValue theArg;
   struct FunctionDefinition *fptr;
   char *stringBuffer = NULL;
   size_t bufferPosition = 0;
   size_t bufferMaximum = 0;
   Environment *theEnv = UDFContextEnvironment(context);

   if (! UDFFirstArgument(context,SYMBOL_TYPE,&theArg))
     { return; }
     
   fptr = FindFunction(theEnv,mCVToString(&theArg));
   if (fptr == NULL)
     {
      CantFindItemErrorMessage(theEnv,"function",mCVToString(&theArg));
      EnvSetEvaluationError(theEnv,true);
      mCVSetString(returnValue,"");
      return;
     }

   if (fptr->returnValueType != 'z')
     {
      if (fptr->restrictions == NULL)
        {
         mCVSetString(returnValue,"0**");
         return;
        }
     
      CVSetCLIPSString(returnValue,fptr->restrictions);
      return;
     }
    
   if (fptr->minArgs == UNBOUNDED)
     {
      stringBuffer = AppendToString(theEnv,"0",
                                    stringBuffer,&bufferPosition,&bufferMaximum);
     }
   else
     {
      stringBuffer = AppendToString(theEnv,LongIntegerToString(theEnv,fptr->minArgs),
                                    stringBuffer,&bufferPosition,&bufferMaximum);
     }
   
   if (fptr->maxArgs == UNBOUNDED)
     {
      stringBuffer = AppendToString(theEnv,"*",
                                    stringBuffer,&bufferPosition,&bufferMaximum);
     }
   else
     {
      stringBuffer = AppendToString(theEnv,LongIntegerToString(theEnv,fptr->maxArgs),
                                    stringBuffer,&bufferPosition,&bufferMaximum);
     }
   
   if (fptr->restrictions == NULL)
     {
      stringBuffer = AppendToString(theEnv,"*",
                                    stringBuffer,&bufferPosition,&bufferMaximum);
     }
   else
     {
      stringBuffer = AppendToString(theEnv,ValueToString(fptr->restrictions),
                                    stringBuffer,&bufferPosition,&bufferMaximum);
     }

   mCVSetString(returnValue,stringBuffer);
   
   rm(theEnv,stringBuffer,bufferMaximum);
  }

/*************************************************/
/* GetFunctionListFunction: H/L access routine   */
/*   for the get-function-list function.         */
/*************************************************/
void GetFunctionListFunction(
  UDFContext *context,
  DATA_OBJECT *returnValue)
  {
   struct FunctionDefinition *theFunction;
   struct multifield *theList;
   unsigned long functionCount = 0;
   Environment *theEnv = UDFContextEnvironment(context);

   for (theFunction = GetFunctionList(theEnv);
        theFunction != NULL;
        theFunction = theFunction->next)
     { functionCount++; }

   SetpType(returnValue,MULTIFIELD);
   SetpDOBegin(returnValue,1);
   SetpDOEnd(returnValue,functionCount);
   theList = (struct multifield *) EnvCreateMultifield(theEnv,functionCount);
   SetpValue(returnValue,(void *) theList);

   for (theFunction = GetFunctionList(theEnv), functionCount = 1;
        theFunction != NULL;
        theFunction = theFunction->next, functionCount++)
     {
      SetMFType(theList,functionCount,SYMBOL);
      SetMFValue(theList,functionCount,theFunction->callFunctionName);
     }
  }

/***************************************/
/* FuncallFunction: H/L access routine */
/*   for the funcall function.         */
/***************************************/
void FuncallFunction(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   int j;
   CLIPSValue theArg;
   FUNCTION_REFERENCE theReference;
   const char *name;
   struct multifield *theMultifield;
   struct expr *lastAdd = NULL, *nextAdd, *multiAdd;
   struct FunctionDefinition *theFunction;
   Environment *theEnv = UDFContextEnvironment(context);
    
   /*==================================*/
   /* Set up the default return value. */
   /*==================================*/
   
   mCVSetBoolean(returnValue,false);
      
   /*============================================*/
   /* Get the name of the function to be called. */
   /*============================================*/
   
   if (! UDFFirstArgument(context,LEXEME_TYPES,&theArg))
     { return; }
   
   /*====================*/
   /* Find the function. */
   /*====================*/

   name = mCVToString(&theArg);
   if (! GetFunctionReference(theEnv,name,&theReference))
     {
      ExpectedTypeError1(theEnv,"funcall",1,"function, deffunction, or generic function name");
      return; 
     }
     
   /*====================================*/
   /* Functions with specialized parsers */
   /* cannot be used with funcall.       */
   /*====================================*/

   if (theReference.type == FCALL)
     {
      theFunction = FindFunction(theEnv,name);
      if (theFunction->parser != NULL)
        {
         ExpectedTypeError1(theEnv,"funcall",1,"function without specialized parser");
         return; 
        }
     }

   /*======================================*/
   /* Add the arguments to the expression. */
   /*======================================*/
     
   ExpressionInstall(theEnv,&theReference);

   while (UDFHasNextArgument(context))
     {
      if (! UDFNextArgument(context,ANY_TYPE,&theArg))
        {
         ExpressionDeinstall(theEnv,&theReference);
         return; 
        }
      
      switch(GetType(theArg))
        {
         case MULTIFIELD:
           nextAdd = GenConstant(theEnv,FCALL,(void *) FindFunction(theEnv,"create$"));

           if (lastAdd == NULL)
             { theReference.argList = nextAdd; }
           else
             { lastAdd->nextArg = nextAdd; }
           lastAdd = nextAdd;

           multiAdd = NULL;
           theMultifield = (struct multifield *) GetValue(theArg);
           for (j = GetDOBegin(theArg); j <= GetDOEnd(theArg); j++)
             {
              nextAdd = GenConstant(theEnv,GetMFType(theMultifield,j),GetMFValue(theMultifield,j));
              if (multiAdd == NULL)
                { lastAdd->argList = nextAdd; }
              else
                { multiAdd->nextArg = nextAdd; }
              multiAdd = nextAdd;
             }

           ExpressionInstall(theEnv,lastAdd);
           break;
         
         default:
           nextAdd = GenConstant(theEnv,GetType(theArg),GetValue(theArg));
           if (lastAdd == NULL)
             { theReference.argList = nextAdd; }
           else
             { lastAdd->nextArg = nextAdd; }
           lastAdd = nextAdd;
           ExpressionInstall(theEnv,lastAdd);
           break;    
        }
     }

   /*===========================================================*/
   /* Verify a deffunction has the correct number of arguments. */
   /*===========================================================*/

#if DEFFUNCTION_CONSTRUCT
   if (theReference.type == PCALL)
     {
      if (CheckDeffunctionCall(theEnv,theReference.value,CountArguments(theReference.argList)) == false)
        {
         PrintErrorID(theEnv,"MISCFUN",4,false);
         EnvPrintRouter(theEnv,WERROR,"Function funcall called with the wrong number of arguments for deffunction ");
         EnvPrintRouter(theEnv,WERROR,EnvGetDeffunctionName(theEnv,theReference.value));
         EnvPrintRouter(theEnv,WERROR,"\n");
         ExpressionDeinstall(theEnv,&theReference);   
         ReturnExpression(theEnv,theReference.argList);
         return;
        }
     }
#endif
     
   /*=========================================*/
   /* Verify the correct number of arguments. */
   /*=========================================*/

   if (theReference.type == FCALL)
     {
      if (CheckExpressionAgainstRestrictions(theEnv,&theReference,theFunction,name))
        {
         ExpressionDeinstall(theEnv,&theReference);
         ReturnExpression(theEnv,theReference.argList);
         return;
        }
     }

   /*======================*/
   /* Call the expression. */
   /*======================*/
   
   EvaluateExpression(theEnv,&theReference,returnValue);
   
   /*========================================*/
   /* Return the expression data structures. */
   /*========================================*/
   
   ExpressionDeinstall(theEnv,&theReference);
   ReturnExpression(theEnv,theReference.argList);
  }
  
/***********************************/
/* NewFunction: H/L access routine */
/*   for the new function.         */
/***********************************/
void NewFunction(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   int theType;
   DATA_OBJECT theValue;
   const char *name;
   Environment *theEnv = UDFContextEnvironment(context);
    
   /*==================================*/
   /* Set up the default return value. */
   /*==================================*/
   
   mCVSetBoolean(returnValue,false);
   
   /*================================================================*/
   /* The new function has at least two arguments: the language type */
   /* of the class (e.g. java, .net, c++) and the name of the class. */
   /*================================================================*/
   
   if (EnvArgCountCheck(theEnv,"new",AT_LEAST,1) == -1) return;
   
   /*====================================*/
   /* Get the name of the language type. */
   /*====================================*/
   
   if (EnvArgTypeCheck(theEnv,"new",1,SYMBOL,&theValue) == false)
     { return; }
   
   /*=========================*/
   /* Find the language type. */
   /*=========================*/

   name = DOToString(theValue);
   
   theType = FindLanguageType(theEnv,name);
   
   if (theType == -1)
     {
      ExpectedTypeError1(theEnv,"new",1,"external language");
      return; 
     }

   /*====================================================*/
   /* Invoke the new function for the specific language. */
   /*====================================================*/
   
   if ((EvaluationData(theEnv)->ExternalAddressTypes[theType] != NULL) &&
       (EvaluationData(theEnv)->ExternalAddressTypes[theType]->newFunction != NULL))
     { (*EvaluationData(theEnv)->ExternalAddressTypes[theType]->newFunction)(theEnv,returnValue); }
  }
  
/************************************/
/* CallFunction: H/L access routine */
/*   for the new function.          */
/************************************/
void CallFunction(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   int theType;
   DATA_OBJECT theValue;
   const char *name;
   int argumentCount;
   struct externalAddressHashNode *theEA;
   Environment *theEnv = UDFContextEnvironment(context);
    
   /*==================================*/
   /* Set up the default return value. */
   /*==================================*/
   
   mCVSetBoolean(returnValue,false);
   
   /*=====================================================*/
   /* The call function has at least one argument: either */
   /* an external address or the language type of the     */
   /* method being called (e.g. java, .net, c++).         */
   /*=====================================================*/
   
   if ((argumentCount = EnvArgCountCheck(theEnv,"call",AT_LEAST,1)) == -1) return;
      
   /*=========================*/
   /* Get the first argument. */
   /*=========================*/
   
   EnvRtnUnknown(theEnv,1,&theValue);

   /*============================================*/
   /* If the first argument is a symbol, then it */
   /* should be an external language type.       */
   /*============================================*/
   
   if (GetType(theValue) == SYMBOL)
     { 
      name = DOToString(theValue);
      
      theType = FindLanguageType(theEnv,name);
      
      if (theType == -1)
        { 
         ExpectedTypeError1(theEnv,"call",1,"external language symbol or external address");
         return;
        }

      /*====================================================================*/
      /* Invoke the call function for the specific language. Typically this */
      /* will invoke a static method of a class (specified with the third   */
      /* and second arguments to the call function.                         */
      /*====================================================================*/
      
      if ((EvaluationData(theEnv)->ExternalAddressTypes[theType] != NULL) &&
          (EvaluationData(theEnv)->ExternalAddressTypes[theType]->callFunction != NULL))
        { (*EvaluationData(theEnv)->ExternalAddressTypes[theType]->callFunction)(theEnv,&theValue,returnValue); }
        
      return;
     }

   /*===============================================*/
   /* If the first argument is an external address, */
   /* then we can determine the external language   */
   /* type be examining the pointer.                */
   /*===============================================*/
   
   if (GetType(theValue) == EXTERNAL_ADDRESS)
     { 
      theEA = (struct externalAddressHashNode *) GetValue(theValue);
      
      theType = theEA->type;
      
      if ((EvaluationData(theEnv)->ExternalAddressTypes[theType] != NULL) &&
          (EvaluationData(theEnv)->ExternalAddressTypes[theType]->callFunction != NULL))
        { (*EvaluationData(theEnv)->ExternalAddressTypes[theType]->callFunction)(theEnv,&theValue,returnValue); }
        
      return;
     }
     
   ExpectedTypeError1(theEnv,"call",1,"external language symbol or external address");
  }

/************************************/
/* FindLanguageType:    */
/************************************/
static int FindLanguageType(
  void *theEnv,
  const char *languageName)
  {
   int theType;
   
   for (theType = 0; theType < EvaluationData(theEnv)->numberOfAddressTypes; theType++)
     {
      if (strcmp(EvaluationData(theEnv)->ExternalAddressTypes[theType]->name,languageName) == 0)
        { return(theType); }
     }
     
   return -1;
  }
     
/************************************/
/* TimeFunction: H/L access routine */
/*   for the time function.         */
/************************************/
void TimeFunction(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   /*==================*/
   /* Return the time. */
   /*==================*/

   mCVSetFloat(returnValue,gentime());
  }

/****************************************/
/* ConvertTime: Function for converting */
/*   time for local-time and gm-time.   */
/****************************************/
static void ConvertTime(
  void *theEnv,
  CLIPSValue *returnValue,
  struct tm *info)
  {
   returnValue->type = MULTIFIELD;
   returnValue->begin = 0;
   returnValue->end = 8;
   returnValue->value = EnvCreateMultifield(theEnv,9L);
   SetMFType(returnValue->value,1,INTEGER);
   SetMFValue(returnValue->value,1,EnvAddLong(theEnv,info->tm_year + 1900));
   SetMFType(returnValue->value,2,INTEGER);
   SetMFValue(returnValue->value,2,EnvAddLong(theEnv,info->tm_mon + 1));
   SetMFType(returnValue->value,3,INTEGER);
   SetMFValue(returnValue->value,3,EnvAddLong(theEnv,info->tm_mday));
   SetMFType(returnValue->value,4,INTEGER);
   SetMFValue(returnValue->value,4,EnvAddLong(theEnv,info->tm_hour));
   SetMFType(returnValue->value,5,INTEGER);
   SetMFValue(returnValue->value,5,EnvAddLong(theEnv,info->tm_min));
   SetMFType(returnValue->value,6,INTEGER);
   SetMFValue(returnValue->value,6,EnvAddLong(theEnv,info->tm_sec));

   SetMFType(returnValue->value,7,SYMBOL);
   switch (info->tm_wday)
     {
      case 0:
        SetMFValue(returnValue->value,7,EnvAddSymbol(theEnv,"Sunday"));
        break;
        
      case 1:
        SetMFValue(returnValue->value,7,EnvAddSymbol(theEnv,"Monday"));
        break;
        
      case 2:
        SetMFValue(returnValue->value,7,EnvAddSymbol(theEnv,"Tuesday"));
        break;
        
      case 3:
        SetMFValue(returnValue->value,7,EnvAddSymbol(theEnv,"Wednesday"));
        break;
        
      case 4:
        SetMFValue(returnValue->value,7,EnvAddSymbol(theEnv,"Thursday"));
        break;
        
      case 5:
        SetMFValue(returnValue->value,7,EnvAddSymbol(theEnv,"Friday"));
        break;
        
      case 6:
        SetMFValue(returnValue->value,7,EnvAddSymbol(theEnv,"Saturday"));
        break;
     }

   SetMFType(returnValue->value,8,INTEGER);
   SetMFValue(returnValue->value,8,EnvAddLong(theEnv,info->tm_yday));

   SetMFType(returnValue->value,9,SYMBOL);
   if (info->tm_isdst > 0)
     { SetMFValue(returnValue->value,9,SymbolData(theEnv)->TrueSymbolHN); }
   else if (info->tm_isdst == 0)
     { SetMFValue(returnValue->value,9,SymbolData(theEnv)->FalseSymbolHN); }
   else
     { SetMFValue(returnValue->value,9,EnvAddSymbol(theEnv,"UNKNOWN")); }
  }

/*****************************************/
/* LocalTimeFunction: H/L access routine */
/*   for the local-time function.        */
/*****************************************/
void LocalTimeFunction(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   time_t rawtime;
   struct tm *info;

   /*=====================*/
   /* Get the local time. */
   /*=====================*/
   
   time(&rawtime);
   info = localtime(&rawtime);
   
   ConvertTime(UDFContextEnvironment(context),returnValue,info);
  }

/**************************************/
/* GMTimeFunction: H/L access routine */
/*   for the gm-time function.        */
/**************************************/
void GMTimeFunction(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   time_t rawtime;
   struct tm *info;

   /*=====================*/
   /* Get the local time. */
   /*=====================*/
   
   time(&rawtime);
   info = gmtime(&rawtime);
   
   ConvertTime(UDFContextEnvironment(context),returnValue,info);
  }

/***************************************/
/* TimerFunction: H/L access routine   */
/*   for the timer function.           */
/***************************************/
void TimerFunction(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   CLIPSFloat startTime;
   CLIPSValue theArg;

   startTime = gentime();
   
   while (UDFHasNextArgument(context) &&
          (! EnvGetHaltExecution(UDFContextEnvironment(context))))
     { UDFNextArgument(context,ANY_TYPE,&theArg); }

   mCVSetFloat(returnValue,gentime() - startTime);
  }

/***************************************/
/* SystemCommand: H/L access routine   */
/*   for the system function.          */
/***************************************/
void SystemCommand(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   char *commandBuffer = NULL;
   size_t bufferPosition = 0;
   size_t bufferMaximum = 0;
   CLIPSValue tempValue;
   const char *theString;
   Environment *theEnv = UDFContextEnvironment(context);

   /*============================================================*/
   /* Concatenate the arguments together to form a single string */
   /* containing the command to be sent to the operating system. */
   /*============================================================*/

   while (UDFHasNextArgument(context))
     {
      if (! UDFNextArgument(context,LEXEME_TYPES,&tempValue))
        { return; }

     theString = mCVToString(&tempValue);

     commandBuffer = AppendToString(theEnv,theString,commandBuffer,&bufferPosition,&bufferMaximum);
    }

   if (commandBuffer == NULL) return;

   /*=======================================*/
   /* Execute the operating system command. */
   /*=======================================*/
   
   gensystem(theEnv,commandBuffer);

   /*==================================================*/
   /* Return the string buffer containing the command. */
   /*==================================================*/

   rm(theEnv,commandBuffer,bufferMaximum);
  }

/*****************************************/
/* SlotValueFunction: H/L access routine */
/*   for the slot-value function.        */
/*****************************************/
void SlotValueFunction(
  UDFContext *context,
  CLIPSValue *returnValue)
  {
#if DEFTEMPLATE_CONSTRUCT
   struct fact *theFact;
#endif
   DATA_OBJECT slotNameReference, factReference, variableSlotReference;
   short position;
   Environment *theEnv = UDFContextEnvironment(context);

   /*=============================================*/
   /* Set up the default return value for errors. */
   /*=============================================*/

   returnValue->type = SYMBOL;
   returnValue->value = EnvFalseSymbol(theEnv);

#if DEFTEMPLATE_CONSTRUCT

   /*===========================*/
   /* Get the name of the slot. */
   /*===========================*/

   if (EnvArgTypeCheck(theEnv,"slot-value",3,SYMBOL,&variableSlotReference) == false)
     { return; }

   /*================================*/
   /* Get the reference to the fact. */
   /*================================*/

   EnvRtnUnknown(theEnv,1,&factReference);
   if (GetType(factReference) == FACT_ADDRESS)
     {
      if (((struct fact *) GetValue(factReference))->garbage)
        {
         PrintErrorID(theEnv,"MISCFUN",5,false);
         EnvPrintRouter(theEnv,WERROR,"The variable/slot reference ?");
         EnvPrintRouter(theEnv,WERROR,DOToString(variableSlotReference));
         EnvPrintRouter(theEnv,WERROR," can not be resolved because the referenced fact has been retracted\n");
         EnvSetEvaluationError(theEnv,true);
         return;
        }
      else
        { theFact = ((struct fact *) GetValue(factReference)); }
     }
   else
     {
      PrintErrorID(theEnv,"MISCFUN",6,false);
      EnvPrintRouter(theEnv,WERROR,"The variable/slot reference ?");
      EnvPrintRouter(theEnv,WERROR,DOToString(variableSlotReference));
      EnvPrintRouter(theEnv,WERROR," can not be resolved because the variable value is not a fact address\n");
      EnvSetEvaluationError(theEnv,true);
      return;
     }
   
   /*===========================*/
   /* Get the name of the slot. */
   /*===========================*/

   if (EnvArgTypeCheck(theEnv,"slot-value",2,SYMBOL,&slotNameReference) == false)
     { return; }

   /*=================================================*/
   /* If the specified slot exists, return the value. */
   /*=================================================*/
   
   if (theFact->whichDeftemplate->implied)
     {
      if (strcmp(DOToString(slotNameReference),"implied") == 0)
        {
         returnValue->type = theFact->theProposition.theFields[0].type;
         returnValue->value = theFact->theProposition.theFields[0].value;
         SetpDOBegin(returnValue,1);
         SetpDOEnd(returnValue,((struct multifield *) returnValue->value)->multifieldLength);
         return;
        }
     }
   else if (FindSlot(theFact->whichDeftemplate,
                     (SYMBOL_HN *) slotNameReference.value,&position) != NULL)
     {
      returnValue->type = theFact->theProposition.theFields[position-1].type;
      returnValue->value = theFact->theProposition.theFields[position-1].value;
      if (returnValue->type == MULTIFIELD)
        {
         SetpDOBegin(returnValue,1);
         SetpDOEnd(returnValue,((struct multifield *) returnValue->value)->multifieldLength);
        }
      return;
     }
     
   /*==========================================*/
   /* Otherwise the specified slot is invalid. */
   /*==========================================*/
   
   PrintErrorID(theEnv,"MISCFUN",7,false);
   EnvPrintRouter(theEnv,WERROR,"The variable/slot reference ?");
   EnvPrintRouter(theEnv,WERROR,DOToString(variableSlotReference));
   EnvPrintRouter(theEnv,WERROR," can not be resolved because referenced fact does not contain the specified slot\n");
   EnvSetEvaluationError(theEnv,true);
#endif
  }
